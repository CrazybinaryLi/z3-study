# Python中的z3 api-Strategies

诸如Z3之类的高性能求解器包含**许多算法证明方法的紧密集成**，手工制作的启发式组合。 
尽管这些启发式组合往往针对已知的问题类别进行了高度调整，但它们在新的问题类别上可能很容易表现很差。 **随着求解器开始引起科学和工程学各个领域的从业者的注意，这个问题变得越来越紧迫。** 
在许多情况下，更改求解器试探法可能会带来巨大的不同。

在本教程中，我们将展示如何使用Z3中可用的基本构建块来创建自定义策略。 
Z3Py和Z3 4.0实现了本文提出的思想。

请向leonardo@microsoft.com发送反馈，评论和/或更正。 您的评论非常有价值。

- http://research.microsoft.com/en-us/um/people/leonardo/strategy.pdf

## 1、介绍

Z3实现了一种用于编排推理引擎的方法，其中将“大”符号推理步骤表示为称为战术的功能，
**并且使用称为战术的组合器来组成战术。战术处理称为目标的公式集。**

将策略应用于**某个目标G**时，**可能会有四个不同的结果。**
该策略成功地表明G是可满足的（即可行的）；
成功表明G不满足要求（即不可行）;
产生一系列子目标；
或失败。
当将目标G减少为子目标G1，...，Gn的序列时，我们面临模型转换的问题。
**模型转换器使用一些子目标Gi的模型构造G的模型。**

在下面的示例中，我们创建一个目标g，该目标g由三个公式组成，一个策略t由两个内置策略组成：
**simple和solve-eqs。**
**简化策略将应用等效于命令simple的转换。**
**战术solver-eqs使用高斯消除法消除变量。**
实际上，solve-eqs不仅仅限于线性算术。它还可以消除任意变量。
然后，组合器然后将简化应用于输入目标，并对由简化产生的每个子目标求解等式。
在此示例中，仅生成一个子目标。

```python
from z3 import *

if __name__ == "__main__":
    x, y = Reals('x y')
    g = Goal()
    g.add(x > 0, y > 0, x == y + 2)
    print(g)  # [x > 0, y > 0, x == y + 2]

    t1 = Tactic('simplify')
    t2 = Tactic('solve-eqs')
    t = Then(t1, t2)
    print(t(g))  # [[Not(y <= -2), Not(y <= 0)]]

```

